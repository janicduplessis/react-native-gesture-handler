{"version":3,"sources":["findNodeHandle.web.ts"],"names":["findNodeHandle","viewRef","viewTag","undefined","HTMLElement","style","display","firstChild","element","current"],"mappings":";;;;;;;AAKe,SAASA,cAAT,CACbC,OADa,EAES;AACtB;AACA;AACA;AACA,MAAI,CAACA,OAAD,aAACA,OAAD,uBAACA,OAAD,CAAgCC,OAAhC,MAA4CC,SAAhD,EAA2D;AACzD,WAAOH,cAAc,CAAEC,OAAD,CAA+BC,OAAhC,CAArB;AACD;;AAED,MAAID,OAAO,YAAYG,WAAvB,EAAoC;AAClC,QAAIH,OAAO,CAACI,KAAR,CAAcC,OAAd,KAA0B,UAA9B,EAA0C;AACxC,aAAON,cAAc,CAACC,OAAO,CAACM,UAAT,CAArB;AACD;;AAED,WAAON,OAAP;AACD,GAdqB,CAgBtB;AACA;;;AACA,MAAIO,OAAO,GAAGP,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAEQ,OAAvB;;AAEA,SAAOD,OAAO,IAAIA,OAAO,CAACH,KAAR,CAAcC,OAAd,KAA0B,UAA5C,EAAwD;AACtDE,IAAAA,OAAO,GAAGA,OAAO,CAACD,UAAlB;AACD;;AAED,SAAOC,OAAP;AACD","sourcesContent":["type GestureHandlerRef = {\n  viewTag: GestureHandlerRef;\n  current: HTMLElement;\n};\n\nexport default function findNodeHandle(\n  viewRef: GestureHandlerRef | HTMLElement\n): HTMLElement | number {\n  // Old API assumes that child handler is HTMLElement.\n  // However, if we nest handlers, we will get ref to another handler.\n  // In that case, we want to recursively call findNodeHandle with new handler viewTag (which can also be ref to another handler).\n  if ((viewRef as GestureHandlerRef)?.viewTag !== undefined) {\n    return findNodeHandle((viewRef as GestureHandlerRef).viewTag);\n  }\n\n  if (viewRef instanceof HTMLElement) {\n    if (viewRef.style.display === 'contents') {\n      return findNodeHandle(viewRef.firstChild as HTMLElement);\n    }\n\n    return viewRef;\n  }\n\n  // In new API, we receive ref object which `current` field points to  wrapper `div` with `display: contents;`.\n  // We want to return the first descendant (in DFS order) that doesn't have this property.\n  let element = viewRef?.current;\n\n  while (element && element.style.display === 'contents') {\n    element = element.firstChild as HTMLElement;\n  }\n\n  return element;\n}\n"]}